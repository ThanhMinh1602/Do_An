// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'navigator.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ScreenType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingPage,
    required TResult Function(NewItemModel newItemModel) newsDetailPage,
    required TResult Function() registerPage,
    required TResult Function() loggedMainPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingPage,
    TResult? Function(NewItemModel newItemModel)? newsDetailPage,
    TResult? Function()? registerPage,
    TResult? Function()? loggedMainPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingPage,
    TResult Function(NewItemModel newItemModel)? newsDetailPage,
    TResult Function()? registerPage,
    TResult Function()? loggedMainPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingPageType value) loadingPage,
    required TResult Function(NewsDetailPageType value) newsDetailPage,
    required TResult Function(RegisterPageType value) registerPage,
    required TResult Function(LoggedMainPageType value) loggedMainPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingPageType value)? loadingPage,
    TResult? Function(NewsDetailPageType value)? newsDetailPage,
    TResult? Function(RegisterPageType value)? registerPage,
    TResult? Function(LoggedMainPageType value)? loggedMainPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingPageType value)? loadingPage,
    TResult Function(NewsDetailPageType value)? newsDetailPage,
    TResult Function(RegisterPageType value)? registerPage,
    TResult Function(LoggedMainPageType value)? loggedMainPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScreenTypeCopyWith<$Res> {
  factory $ScreenTypeCopyWith(
          ScreenType value, $Res Function(ScreenType) then) =
      _$ScreenTypeCopyWithImpl<$Res, ScreenType>;
}

/// @nodoc
class _$ScreenTypeCopyWithImpl<$Res, $Val extends ScreenType>
    implements $ScreenTypeCopyWith<$Res> {
  _$ScreenTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadingPageTypeImplCopyWith<$Res> {
  factory _$$LoadingPageTypeImplCopyWith(_$LoadingPageTypeImpl value,
          $Res Function(_$LoadingPageTypeImpl) then) =
      __$$LoadingPageTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingPageTypeImplCopyWithImpl<$Res>
    extends _$ScreenTypeCopyWithImpl<$Res, _$LoadingPageTypeImpl>
    implements _$$LoadingPageTypeImplCopyWith<$Res> {
  __$$LoadingPageTypeImplCopyWithImpl(
      _$LoadingPageTypeImpl _value, $Res Function(_$LoadingPageTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingPageTypeImpl implements LoadingPageType {
  const _$LoadingPageTypeImpl();

  @override
  String toString() {
    return 'ScreenType.loadingPage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingPageTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingPage,
    required TResult Function(NewItemModel newItemModel) newsDetailPage,
    required TResult Function() registerPage,
    required TResult Function() loggedMainPage,
  }) {
    return loadingPage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingPage,
    TResult? Function(NewItemModel newItemModel)? newsDetailPage,
    TResult? Function()? registerPage,
    TResult? Function()? loggedMainPage,
  }) {
    return loadingPage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingPage,
    TResult Function(NewItemModel newItemModel)? newsDetailPage,
    TResult Function()? registerPage,
    TResult Function()? loggedMainPage,
    required TResult orElse(),
  }) {
    if (loadingPage != null) {
      return loadingPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingPageType value) loadingPage,
    required TResult Function(NewsDetailPageType value) newsDetailPage,
    required TResult Function(RegisterPageType value) registerPage,
    required TResult Function(LoggedMainPageType value) loggedMainPage,
  }) {
    return loadingPage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingPageType value)? loadingPage,
    TResult? Function(NewsDetailPageType value)? newsDetailPage,
    TResult? Function(RegisterPageType value)? registerPage,
    TResult? Function(LoggedMainPageType value)? loggedMainPage,
  }) {
    return loadingPage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingPageType value)? loadingPage,
    TResult Function(NewsDetailPageType value)? newsDetailPage,
    TResult Function(RegisterPageType value)? registerPage,
    TResult Function(LoggedMainPageType value)? loggedMainPage,
    required TResult orElse(),
  }) {
    if (loadingPage != null) {
      return loadingPage(this);
    }
    return orElse();
  }
}

abstract class LoadingPageType implements ScreenType {
  const factory LoadingPageType() = _$LoadingPageTypeImpl;
}

/// @nodoc
abstract class _$$NewsDetailPageTypeImplCopyWith<$Res> {
  factory _$$NewsDetailPageTypeImplCopyWith(_$NewsDetailPageTypeImpl value,
          $Res Function(_$NewsDetailPageTypeImpl) then) =
      __$$NewsDetailPageTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({NewItemModel newItemModel});
}

/// @nodoc
class __$$NewsDetailPageTypeImplCopyWithImpl<$Res>
    extends _$ScreenTypeCopyWithImpl<$Res, _$NewsDetailPageTypeImpl>
    implements _$$NewsDetailPageTypeImplCopyWith<$Res> {
  __$$NewsDetailPageTypeImplCopyWithImpl(_$NewsDetailPageTypeImpl _value,
      $Res Function(_$NewsDetailPageTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newItemModel = null,
  }) {
    return _then(_$NewsDetailPageTypeImpl(
      null == newItemModel
          ? _value.newItemModel
          : newItemModel // ignore: cast_nullable_to_non_nullable
              as NewItemModel,
    ));
  }
}

/// @nodoc

class _$NewsDetailPageTypeImpl implements NewsDetailPageType {
  const _$NewsDetailPageTypeImpl(this.newItemModel);

  @override
  final NewItemModel newItemModel;

  @override
  String toString() {
    return 'ScreenType.newsDetailPage(newItemModel: $newItemModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NewsDetailPageTypeImpl &&
            (identical(other.newItemModel, newItemModel) ||
                other.newItemModel == newItemModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newItemModel);

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NewsDetailPageTypeImplCopyWith<_$NewsDetailPageTypeImpl> get copyWith =>
      __$$NewsDetailPageTypeImplCopyWithImpl<_$NewsDetailPageTypeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingPage,
    required TResult Function(NewItemModel newItemModel) newsDetailPage,
    required TResult Function() registerPage,
    required TResult Function() loggedMainPage,
  }) {
    return newsDetailPage(newItemModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingPage,
    TResult? Function(NewItemModel newItemModel)? newsDetailPage,
    TResult? Function()? registerPage,
    TResult? Function()? loggedMainPage,
  }) {
    return newsDetailPage?.call(newItemModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingPage,
    TResult Function(NewItemModel newItemModel)? newsDetailPage,
    TResult Function()? registerPage,
    TResult Function()? loggedMainPage,
    required TResult orElse(),
  }) {
    if (newsDetailPage != null) {
      return newsDetailPage(newItemModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingPageType value) loadingPage,
    required TResult Function(NewsDetailPageType value) newsDetailPage,
    required TResult Function(RegisterPageType value) registerPage,
    required TResult Function(LoggedMainPageType value) loggedMainPage,
  }) {
    return newsDetailPage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingPageType value)? loadingPage,
    TResult? Function(NewsDetailPageType value)? newsDetailPage,
    TResult? Function(RegisterPageType value)? registerPage,
    TResult? Function(LoggedMainPageType value)? loggedMainPage,
  }) {
    return newsDetailPage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingPageType value)? loadingPage,
    TResult Function(NewsDetailPageType value)? newsDetailPage,
    TResult Function(RegisterPageType value)? registerPage,
    TResult Function(LoggedMainPageType value)? loggedMainPage,
    required TResult orElse(),
  }) {
    if (newsDetailPage != null) {
      return newsDetailPage(this);
    }
    return orElse();
  }
}

abstract class NewsDetailPageType implements ScreenType {
  const factory NewsDetailPageType(final NewItemModel newItemModel) =
      _$NewsDetailPageTypeImpl;

  NewItemModel get newItemModel;

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NewsDetailPageTypeImplCopyWith<_$NewsDetailPageTypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RegisterPageTypeImplCopyWith<$Res> {
  factory _$$RegisterPageTypeImplCopyWith(_$RegisterPageTypeImpl value,
          $Res Function(_$RegisterPageTypeImpl) then) =
      __$$RegisterPageTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RegisterPageTypeImplCopyWithImpl<$Res>
    extends _$ScreenTypeCopyWithImpl<$Res, _$RegisterPageTypeImpl>
    implements _$$RegisterPageTypeImplCopyWith<$Res> {
  __$$RegisterPageTypeImplCopyWithImpl(_$RegisterPageTypeImpl _value,
      $Res Function(_$RegisterPageTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RegisterPageTypeImpl implements RegisterPageType {
  const _$RegisterPageTypeImpl();

  @override
  String toString() {
    return 'ScreenType.registerPage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RegisterPageTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingPage,
    required TResult Function(NewItemModel newItemModel) newsDetailPage,
    required TResult Function() registerPage,
    required TResult Function() loggedMainPage,
  }) {
    return registerPage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingPage,
    TResult? Function(NewItemModel newItemModel)? newsDetailPage,
    TResult? Function()? registerPage,
    TResult? Function()? loggedMainPage,
  }) {
    return registerPage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingPage,
    TResult Function(NewItemModel newItemModel)? newsDetailPage,
    TResult Function()? registerPage,
    TResult Function()? loggedMainPage,
    required TResult orElse(),
  }) {
    if (registerPage != null) {
      return registerPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingPageType value) loadingPage,
    required TResult Function(NewsDetailPageType value) newsDetailPage,
    required TResult Function(RegisterPageType value) registerPage,
    required TResult Function(LoggedMainPageType value) loggedMainPage,
  }) {
    return registerPage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingPageType value)? loadingPage,
    TResult? Function(NewsDetailPageType value)? newsDetailPage,
    TResult? Function(RegisterPageType value)? registerPage,
    TResult? Function(LoggedMainPageType value)? loggedMainPage,
  }) {
    return registerPage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingPageType value)? loadingPage,
    TResult Function(NewsDetailPageType value)? newsDetailPage,
    TResult Function(RegisterPageType value)? registerPage,
    TResult Function(LoggedMainPageType value)? loggedMainPage,
    required TResult orElse(),
  }) {
    if (registerPage != null) {
      return registerPage(this);
    }
    return orElse();
  }
}

abstract class RegisterPageType implements ScreenType {
  const factory RegisterPageType() = _$RegisterPageTypeImpl;
}

/// @nodoc
abstract class _$$LoggedMainPageTypeImplCopyWith<$Res> {
  factory _$$LoggedMainPageTypeImplCopyWith(_$LoggedMainPageTypeImpl value,
          $Res Function(_$LoggedMainPageTypeImpl) then) =
      __$$LoggedMainPageTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoggedMainPageTypeImplCopyWithImpl<$Res>
    extends _$ScreenTypeCopyWithImpl<$Res, _$LoggedMainPageTypeImpl>
    implements _$$LoggedMainPageTypeImplCopyWith<$Res> {
  __$$LoggedMainPageTypeImplCopyWithImpl(_$LoggedMainPageTypeImpl _value,
      $Res Function(_$LoggedMainPageTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ScreenType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoggedMainPageTypeImpl implements LoggedMainPageType {
  const _$LoggedMainPageTypeImpl();

  @override
  String toString() {
    return 'ScreenType.loggedMainPage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoggedMainPageTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingPage,
    required TResult Function(NewItemModel newItemModel) newsDetailPage,
    required TResult Function() registerPage,
    required TResult Function() loggedMainPage,
  }) {
    return loggedMainPage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingPage,
    TResult? Function(NewItemModel newItemModel)? newsDetailPage,
    TResult? Function()? registerPage,
    TResult? Function()? loggedMainPage,
  }) {
    return loggedMainPage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingPage,
    TResult Function(NewItemModel newItemModel)? newsDetailPage,
    TResult Function()? registerPage,
    TResult Function()? loggedMainPage,
    required TResult orElse(),
  }) {
    if (loggedMainPage != null) {
      return loggedMainPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingPageType value) loadingPage,
    required TResult Function(NewsDetailPageType value) newsDetailPage,
    required TResult Function(RegisterPageType value) registerPage,
    required TResult Function(LoggedMainPageType value) loggedMainPage,
  }) {
    return loggedMainPage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingPageType value)? loadingPage,
    TResult? Function(NewsDetailPageType value)? newsDetailPage,
    TResult? Function(RegisterPageType value)? registerPage,
    TResult? Function(LoggedMainPageType value)? loggedMainPage,
  }) {
    return loggedMainPage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingPageType value)? loadingPage,
    TResult Function(NewsDetailPageType value)? newsDetailPage,
    TResult Function(RegisterPageType value)? registerPage,
    TResult Function(LoggedMainPageType value)? loggedMainPage,
    required TResult orElse(),
  }) {
    if (loggedMainPage != null) {
      return loggedMainPage(this);
    }
    return orElse();
  }
}

abstract class LoggedMainPageType implements ScreenType {
  const factory LoggedMainPageType() = _$LoggedMainPageTypeImpl;
}

/// @nodoc
mixin _$NavigationType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() root,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? root,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? root,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NavigationTypeRoot value) root,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NavigationTypeRoot value)? root,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NavigationTypeRoot value)? root,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NavigationTypeCopyWith<$Res> {
  factory $NavigationTypeCopyWith(
          NavigationType value, $Res Function(NavigationType) then) =
      _$NavigationTypeCopyWithImpl<$Res, NavigationType>;
}

/// @nodoc
class _$NavigationTypeCopyWithImpl<$Res, $Val extends NavigationType>
    implements $NavigationTypeCopyWith<$Res> {
  _$NavigationTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NavigationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NavigationTypeRootImplCopyWith<$Res> {
  factory _$$NavigationTypeRootImplCopyWith(_$NavigationTypeRootImpl value,
          $Res Function(_$NavigationTypeRootImpl) then) =
      __$$NavigationTypeRootImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NavigationTypeRootImplCopyWithImpl<$Res>
    extends _$NavigationTypeCopyWithImpl<$Res, _$NavigationTypeRootImpl>
    implements _$$NavigationTypeRootImplCopyWith<$Res> {
  __$$NavigationTypeRootImplCopyWithImpl(_$NavigationTypeRootImpl _value,
      $Res Function(_$NavigationTypeRootImpl) _then)
      : super(_value, _then);

  /// Create a copy of NavigationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NavigationTypeRootImpl implements NavigationTypeRoot {
  const _$NavigationTypeRootImpl();

  @override
  String toString() {
    return 'NavigationType.root()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NavigationTypeRootImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() root,
  }) {
    return root();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? root,
  }) {
    return root?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? root,
    required TResult orElse(),
  }) {
    if (root != null) {
      return root();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NavigationTypeRoot value) root,
  }) {
    return root(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NavigationTypeRoot value)? root,
  }) {
    return root?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NavigationTypeRoot value)? root,
    required TResult orElse(),
  }) {
    if (root != null) {
      return root(this);
    }
    return orElse();
  }
}

abstract class NavigationTypeRoot implements NavigationType {
  const factory NavigationTypeRoot() = _$NavigationTypeRootImpl;
}
